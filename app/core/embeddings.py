"""
Embedding utilities for ticket similarity search

This module provides functions to load and search ticket embeddings
generated by the generate_ticket_embeddings.py utility script.
"""

import json
import math
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass

@dataclass
class TicketEmbedding:
    """Represents a ticket embedding with metadata"""
    ticket_id: str
    content_hash: str
    embedding: List[float]
    content_preview: str
    generated_at: str
    token_count: int

@dataclass
class SimilarityResult:
    """Represents a similarity search result"""
    ticket_id: str
    similarity: float
    content_preview: str
    
    def __str__(self):
        return f"{self.ticket_id} (similarity: {self.similarity:.4f})"

class EmbeddingManager:
    """Manages ticket embeddings for similarity search"""
    
    def __init__(self, embeddings_file: str = "data/ticket_embeddings.json"):
        """
        Initialize the embedding manager
        
        Args:
            embeddings_file: Path to the embeddings JSON file
        """
        self.embeddings_file = Path(embeddings_file)
        self.embeddings: Dict[str, TicketEmbedding] = {}
        self.metadata: Dict[str, Any] = {}
        self._load_embeddings()
    
    def _load_embeddings(self) -> None:
        """Load embeddings from file"""
        if not self.embeddings_file.exists():
            print(f"‚ö†Ô∏è  Embeddings file not found: {self.embeddings_file}")
            print("   Run 'python generate_ticket_embeddings.py' to generate embeddings")
            return
        
        try:
            with open(self.embeddings_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            self.metadata = data.get("metadata", {})
            
            # Load embeddings into dataclass objects
            for embedding_data in data.get("embeddings", []):
                ticket_embedding = TicketEmbedding(
                    ticket_id=embedding_data["ticket_id"],
                    content_hash=embedding_data["content_hash"],
                    embedding=embedding_data["embedding"],
                    content_preview=embedding_data["content_preview"],
                    generated_at=embedding_data["generated_at"],
                    token_count=embedding_data["token_count"]
                )
                self.embeddings[ticket_embedding.ticket_id] = ticket_embedding
                
        except Exception as e:
            print(f"‚ùå Error loading embeddings: {e}")
    
    def cosine_similarity(self, vec1: List[float], vec2: List[float]) -> float:
        """
        Calculate cosine similarity between two vectors
        
        Args:
            vec1: First vector
            vec2: Second vector
            
        Returns:
            Similarity score between -1 and 1 (1 = identical, 0 = orthogonal, -1 = opposite)
        """
        if len(vec1) != len(vec2):
            raise ValueError(f"Vector dimensions don't match: {len(vec1)} vs {len(vec2)}")
        
        # Calculate dot product
        dot_product = sum(a * b for a, b in zip(vec1, vec2))
        
        # Calculate magnitudes
        magnitude1 = math.sqrt(sum(a * a for a in vec1))
        magnitude2 = math.sqrt(sum(a * a for a in vec2))
        
        # Avoid division by zero
        if magnitude1 == 0 or magnitude2 == 0:
            return 0.0
        
        return dot_product / (magnitude1 * magnitude2)
    
    def find_similar_tickets(
        self, 
        query_embedding: List[float], 
        top_k: int = 5,
        min_similarity: float = 0.0
    ) -> List[SimilarityResult]:
        """
        Find tickets similar to a query embedding
        
        Args:
            query_embedding: The embedding vector to search for
            top_k: Maximum number of results to return
            min_similarity: Minimum similarity threshold (0.0 to 1.0)
            
        Returns:
            List of similarity results, sorted by similarity (highest first)
        """
        if not self.embeddings:
            return []
        
        similarities = []
        
        for ticket_id, ticket_embedding in self.embeddings.items():
            similarity = self.cosine_similarity(query_embedding, ticket_embedding.embedding)
            
            if similarity >= min_similarity:
                similarities.append(SimilarityResult(
                    ticket_id=ticket_id,
                    similarity=similarity,
                    content_preview=ticket_embedding.content_preview
                ))
        
        # Sort by similarity (highest first) and return top_k
        similarities.sort(key=lambda x: x.similarity, reverse=True)
        return similarities[:top_k]
    
    def find_similar_to_ticket(
        self, 
        ticket_id: str, 
        top_k: int = 5,
        min_similarity: float = 0.0
    ) -> List[SimilarityResult]:
        """
        Find tickets similar to an existing ticket
        
        Args:
            ticket_id: ID of the ticket to find similarities for
            top_k: Maximum number of results to return
            min_similarity: Minimum similarity threshold (0.0 to 1.0)
            
        Returns:
            List of similarity results, excluding the query ticket itself
        """
        if ticket_id not in self.embeddings:
            print(f"‚ö†Ô∏è  Ticket {ticket_id} not found in embeddings")
            return []
        
        query_embedding = self.embeddings[ticket_id].embedding
        results = self.find_similar_tickets(query_embedding, top_k + 1, min_similarity)
        
        # Remove the query ticket itself from results
        return [result for result in results if result.ticket_id != ticket_id][:top_k]
    
    def get_embedding_info(self) -> Dict[str, Any]:
        """
        Get information about loaded embeddings
        
        Returns:
            Dictionary with embedding metadata and statistics
        """
        return {
            "total_embeddings": len(self.embeddings),
            "model": self.metadata.get("model", "unknown"),
            "dimension": self.metadata.get("dimension", 0),
            "generated_at": self.metadata.get("generated_at", "unknown"),
            "processing_stats": self.metadata.get("processing_stats", {}),
            "available_tickets": list(self.embeddings.keys())
        }
    
    def has_ticket(self, ticket_id: str) -> bool:
        """Check if a ticket has an embedding"""
        return ticket_id in self.embeddings
    
    def get_ticket_embedding(self, ticket_id: str) -> Optional[TicketEmbedding]:
        """Get the embedding for a specific ticket"""
        return self.embeddings.get(ticket_id)

# Convenience functions for easy import and use

def load_embeddings(embeddings_file: str = "data/ticket_embeddings.json") -> EmbeddingManager:
    """
    Load embeddings and return an EmbeddingManager instance
    
    Args:
        embeddings_file: Path to the embeddings JSON file
        
    Returns:
        EmbeddingManager instance
    """
    return EmbeddingManager(embeddings_file)

def find_similar_tickets(
    query_embedding: List[float], 
    top_k: int = 5,
    embeddings_file: str = "data/ticket_embeddings.json"
) -> List[SimilarityResult]:
    """
    Convenience function to find similar tickets
    
    Args:
        query_embedding: The embedding vector to search for
        top_k: Maximum number of results to return
        embeddings_file: Path to the embeddings JSON file
        
    Returns:
        List of similarity results
    """
    manager = EmbeddingManager(embeddings_file)
    return manager.find_similar_tickets(query_embedding, top_k)

class TicketEmbeddingSystem:
    """High-level ticket embedding system for research agents"""
    
    def __init__(self):
        """Initialize the ticket embedding system"""
        self.embedding_manager = EmbeddingManager()
        self.embeddings_cache = {}  # For compatibility with research agents
        
        # Load existing embeddings into cache
        self._load_embeddings_to_cache()
    
    def _load_embeddings_to_cache(self):
        """Load embeddings into cache format expected by research agents"""
        for ticket_id, embedding_obj in self.embedding_manager.embeddings.items():
            self.embeddings_cache[ticket_id] = embedding_obj.embedding
    
    def find_similar_tickets(self, query_ticket, historical_tickets):
        """
        Find similar tickets for research agents
        
        Args:
            query_ticket: The ticket to find similarities for
            historical_tickets: List of historical tickets to search in
            
        Returns:
            TicketSimilarityResult object
        """
        from app.core.research_models import TicketSimilarityResult, SimilarTicket
        
        try:
            # Generate embedding for query ticket if needed
            query_embedding = self._get_or_generate_embedding(query_ticket)
            
            # Find similar tickets using embedding manager with optimized threshold
            similar_results = self.embedding_manager.find_similar_tickets(
                query_embedding, top_k=3, min_similarity=0.60  # Raised minimum threshold
            )
            
            # Filter to only include historical tickets that exist in our dataset
            historical_ticket_ids = {t.ticket_id for t in historical_tickets}
            filtered_results = [r for r in similar_results if r.ticket_id in historical_ticket_ids]
            
            # Further filter for high similarity (75%+) for "high similarity detection"
            high_similarity_results = [r for r in filtered_results if r.similarity >= 0.75]
            
            if high_similarity_results:
                # Convert to SimilarTicket objects with German key learnings
                similar_tickets = []
                for result in high_similarity_results:
                    # Find the actual ticket object
                    historical_ticket = next((t for t in historical_tickets if t.ticket_id == result.ticket_id), None)
                    
                    if historical_ticket:
                        # Generate German key learnings from resolution
                        key_learnings = self._generate_german_key_learnings(historical_ticket)
                        
                        similar_ticket = SimilarTicket(
                            ticket_id=result.ticket_id,
                            title=historical_ticket.title,
                            similarity_score=result.similarity,
                            resolution_summary=getattr(historical_ticket, 'resolution', 'L√∂sung nicht verf√ºgbar')[:200],
                            key_learnings=key_learnings
                        )
                        similar_tickets.append(similar_ticket)
                
                return TicketSimilarityResult(
                    similar_tickets_found=True,
                    similar_tickets=similar_tickets,
                    similarity_threshold_used=0.75,
                    search_summary=f"Gefunden: {len(similar_tickets)} √§hnliche Tickets mit √Ñhnlichkeit ‚â•75%"
                )
            
            # Check for medium similarity (60-74%) if no high similarity found
            elif filtered_results:
                similar_tickets = []
                for result in filtered_results:
                    historical_ticket = next((t for t in historical_tickets if t.ticket_id == result.ticket_id), None)
                    
                    if historical_ticket:
                        key_learnings = self._generate_german_key_learnings(historical_ticket)
                        
                        similar_ticket = SimilarTicket(
                            ticket_id=result.ticket_id,
                            title=historical_ticket.title,
                            similarity_score=result.similarity,
                            resolution_summary=getattr(historical_ticket, 'resolution', 'L√∂sung nicht verf√ºgbar')[:200],
                            key_learnings=key_learnings
                        )
                        similar_tickets.append(similar_ticket)
                
                return TicketSimilarityResult(
                    similar_tickets_found=True,
                    similar_tickets=similar_tickets,
                    similarity_threshold_used=0.60,
                    search_summary=f"Gefunden: {len(similar_tickets)} verwandte Tickets mit mittlerer √Ñhnlichkeit (60-74%)"
                )
            else:
                return TicketSimilarityResult(
                    similar_tickets_found=False,
                    similar_tickets=[],
                    similarity_threshold_used=0.75,
                    search_summary="Keine √§hnlichen Tickets √ºber der Schwelle gefunden"
                )
                
        except Exception as e:
            return TicketSimilarityResult(
                similar_tickets_found=False,
                similar_tickets=[],
                similarity_threshold_used=0.75,
                search_summary=f"Fehler bei der √Ñhnlichkeitssuche: {str(e)}"
            )
    
    def _get_or_generate_embedding(self, ticket):
        """Get or generate embedding for a ticket"""
        # First check if we already have an embedding
        if ticket.ticket_id in self.embeddings_cache:
            return self.embeddings_cache[ticket.ticket_id]
        
        # Generate new embedding using LLM client
        try:
            from app.core.llm_client import LLMClient
            client = LLMClient()
            
            # Create content for embedding (same strategy as generate_ticket_embeddings.py)
            content = f"Title: {ticket.title}\n\nBody: {ticket.body}"
            if hasattr(ticket, 'resolution') and ticket.resolution:
                content += f"\n\nResolution: {ticket.resolution}"
            
            # Generate embedding
            embedding = client.get_embedding(content)
            
            # Cache the result
            self.embeddings_cache[ticket.ticket_id] = embedding
            
            return embedding
            
        except Exception as e:
            print(f"Error generating embedding for ticket {ticket.ticket_id}: {e}")
            # Return a dummy embedding vector of correct size
            return [0.0] * 1536
    
    def _generate_german_key_learnings(self, historical_ticket):
        """Generate German key learnings from historical ticket resolution"""
        try:
            # Extract key insights from resolution and ticket summary
            resolution = getattr(historical_ticket, 'resolution', '')
            summary = getattr(historical_ticket, 'summary', {})
            
            if summary and isinstance(summary, dict):
                # Use structured summary if available
                root_cause = summary.get('root_cause', '')
                steps_taken = summary.get('steps_taken', '')
                future_cues = summary.get('future_cues', [])
                
                key_points = []
                
                if root_cause:
                    key_points.append(f"Ursache: {root_cause}")
                
                if steps_taken:
                    key_points.append(f"L√∂sung: {steps_taken}")
                
                if future_cues and isinstance(future_cues, list):
                    # Take first 2 future cues for key learnings
                    for cue in future_cues[:2]:
                        key_points.append(f"Empfehlung: {cue}")
                
                if key_points:
                    return '; '.join(key_points)
            
            # Fallback: extract key insights from resolution text
            if resolution:
                # Simple extraction for demo - in production would use LLM
                if 'Saugh√∂he' in resolution and 'reduziert' in resolution:
                    return "Saugh√∂he pr√ºfen und reduzieren falls zu hoch; Installationsrichtlinien beachten"
                elif 'Wartung' in resolution and 'Reinigung' in resolution:
                    return "Regelm√§√üige Wartung erforderlich; Spezielle Reinigung f√ºr hochviskose Medien"
                elif 'Temperatur' in resolution:
                    return "Mediumtemperatur √ºberwachen; Bei hochviskosen Medien Beheizung nutzen"
                else:
                    # Generic learning
                    return "Technische Spezifikationen beachten; Bei Problemen Handbuch konsultieren"
            
            return "Strukturierte Probleml√∂sung anwenden; Dokumentation f√ºr zuk√ºnftige F√§lle nutzen"
            
        except Exception as e:
            return "Erfahrungswerte aus √§hnlichen F√§llen anwenden"
    
    def generate_embeddings_for_tickets(self, tickets):
        """Generate embeddings for a list of tickets (compatibility method)"""
        for ticket in tickets:
            self._get_or_generate_embedding(ticket)

# Example usage functions for testing

def demo_similarity_search():
    """Demo function showing how to use the embedding system"""
    print("üîç Embedding Similarity Search Demo")
    print("=" * 50)
    
    # Load embeddings
    manager = load_embeddings()
    info = manager.get_embedding_info()
    
    print(f"üìä Loaded {info['total_embeddings']} embeddings")
    print(f"ü§ñ Model: {info['model']}")
    print(f"üìè Dimensions: {info['dimension']}")
    print()
    
    # Show available tickets
    print("üé´ Available tickets:")
    for ticket_id in info['available_tickets']:
        embedding = manager.get_ticket_embedding(ticket_id)
        print(f"   {ticket_id}: {embedding.content_preview}")
    print()
    
    # Find tickets similar to each ticket
    for ticket_id in info['available_tickets']:
        print(f"üîç Tickets similar to {ticket_id}:")
        similar = manager.find_similar_to_ticket(ticket_id, top_k=3, min_similarity=0.1)
        
        if similar:
            for result in similar:
                print(f"   ‚Ä¢ {result}")
        else:
            print("   ‚Ä¢ No similar tickets found")
        print()

if __name__ == "__main__":
    demo_similarity_search()
